{"version":3,"sources":["webpack:///./node_modules/bootstrap-vue/esm/directives/scrollspy/index.js","webpack:///./node_modules/bootstrap-vue/esm/directives/tooltip/tooltip.js","webpack:///./node_modules/bootstrap-vue/esm/directives/scrollspy/scrollspy.class.js","webpack:///./node_modules/bootstrap-vue/esm/directives/scrollspy/scrollspy.js","webpack:///./node_modules/bootstrap-vue/esm/directives/popover/index.js","webpack:///./node_modules/bootstrap-vue/esm/directives/toggle/toggle.js","webpack:///./node_modules/bootstrap-vue/esm/directives/visible.js","webpack:///./node_modules/bootstrap-vue/esm/directives/tooltip/index.js","webpack:///./node_modules/bootstrap-vue/esm/directives/popover/popover.js","webpack:///./node_modules/bootstrap-vue/esm/directives/modal/index.js","webpack:///./node_modules/bootstrap-vue/esm/directives/modal/modal.js","webpack:///./node_modules/bootstrap-vue/esm/directives/toggle/index.js","webpack:///./node_modules/bootstrap-vue/esm/directives/index.js"],"names":["VBScrollspyPlugin","directives","VBScrollspy","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","BV_TOOLTIP","DefaultTrigger","validTriggers","focus","hover","click","blur","manual","htmlRE","noFadeRE","placementRE","boundaryRE","delayRE","delayShowRE","delayHideRE","offsetRE","variantRE","parseBindings","bindings","vnode","NAME","config","title","undefined","trigger","placement","fallbackPlacement","container","animation","offset","id","html","disabled","delay","boundary","String","boundaryPadding","parseInt","variant","customClass","data","attrs","show","hide","arg","concat","modifiers","mod","test","slice","selectedTriggers","Boolean","join","trim","toLowerCase","split","applyTooltip","el","$parent","context","parent","_scopeId","__bv_prev_data__","$on","updateData","triggers","noFade","oldData","newData","prop","removeTooltip","$destroy","VBTooltip","bind","componentUpdated","$nextTick","unbind","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","prototype","ACTIVATE_EVENT","Default","element","method","throttle","DefaultType","ClassName","DROPDOWN_ITEM","ACTIVE","Selector","NAV_LIST_GROUP","NAV_LINKS","NAV_ITEMS","LIST_ITEMS","DROPDOWN","DROPDOWN_ITEMS","DROPDOWN_TOGGLE","OffsetMethod","OFFSET","POSITION","HREF_REGEX","TransitionEndEvents","EventOptions","passive","capture","match","componentName","configTypes","property","hasOwnProperty","call","expectedTypes","valueType","_isVue","RegExp","warn","ScrollSpy","$root","this","$el","$scroller","$selector","$offsets","$targets","$activeTarget","$scrollHeight","$resizeTimeout","$obs_scroller","$obs_targets","$config","updateConfig","unlisten","cfg","constructor","Name","self","listen","clearTimeout","_this","scroller","getScroller","tagName","window","evtName","setObservers","handleEvent","_this2","on","_this3","disconnect","subtree","childList","attributes","attributeFilter","characterData","evt","type","resizeThrottle","setTimeout","refresh","process","_this4","autoMethod","methodFn","offsetBase","getScrollTop","getScrollHeight","map","link","href","replace","top","sort","a","b","reduce","memo","item","scrollTop","scrollHeight","maxScroll","getOffsetHeight","activate","clear","isActiveTarget","pageYOffset","Math","max","document","body","documentElement","innerHeight","height","_this5","links","selector","dropdown","setActiveState","parentElement","sibling","previousElementSibling","$emit","_this6","active","get","BV_SCROLLSPY","round","k","removeScrollspy","dispose","inserted","update","oldValue","VBPopoverPlugin","VBPopover","listenTypes","BV_TOGGLE","BV_TOGGLE_STATE","BV_TOGGLE_CONTROLS","BV_TOGGLE_TARGETS","EVENT_TOGGLE","EVENT_STATE","EVENT_STATE_SYNC","EVENT_STATE_REQUEST","resetProp","handleTargets","_ref","targets","handleUpdate","binding","VBToggle","toggleDirectiveHandler","state","indexOf","updated","$off","OBSERVER_PROP_NAME","VisibilityObserver","options","callback","margin","once","observer","visible","doneOnce","createObserver","stop","IntersectionObserver","handler","root","rootMargin","threshold","_unused","observe","entries","entry","isIntersecting","intersectionRatio","destroy","_prevModifiers","_ref2","VBVisible","VBTooltipPlugin","BV_POPOVER","content","applyPopover","removePopover","VBModalPlugin","VBModal","EVENT_SHOW","HANDLER","EVENT_OPTS","getTarget","_ref$modifiers","reverse","getTriggerElement","setRole","currentTarget","keyCode","VBTogglePlugin","directivesPlugin","plugins"],"mappings":"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","file":"chunk-vendors~3cd7fc04.js","sourcesContent":["import { VBScrollspy } from './scrollspy';\nimport { pluginFactory } from '../../utils/plugins';\nvar VBScrollspyPlugin =\n/*#__PURE__*/\npluginFactory({\n  directives: {\n    VBScrollspy: VBScrollspy\n  }\n});\nexport { VBScrollspyPlugin, VBScrollspy };","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport getScopId from '../../utils/get-scope-id';\nimport looseEqual from '../../utils/loose-equal';\nimport { concat } from '../../utils/array';\nimport { getComponentConfig } from '../../utils/config';\nimport { isBrowser } from '../../utils/env';\nimport { isFunction, isNumber, isPlainObject, isString, isUndefined, isUndefinedOrNull } from '../../utils/inspect';\nimport { keys } from '../../utils/object';\nimport { BVTooltip } from '../../components/tooltip/helpers/bv-tooltip'; // Key which we use to store tooltip object on element\n\nvar BV_TOOLTIP = '__BV_Tooltip__'; // Default trigger\n\nvar DefaultTrigger = 'hover focus'; // Valid event triggers\n\nvar validTriggers = {\n  focus: true,\n  hover: true,\n  click: true,\n  blur: true,\n  manual: true\n}; // Directive modifier test regular expressions. Pre-compile for performance\n\nvar htmlRE = /^html$/i;\nvar noFadeRE = /^nofade$/i;\nvar placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;\nvar boundaryRE = /^(window|viewport|scrollParent)$/i;\nvar delayRE = /^d\\d+$/i;\nvar delayShowRE = /^ds\\d+$/i;\nvar delayHideRE = /^dh\\d+$/i;\nvar offsetRE = /^o-?\\d+$/i;\nvar variantRE = /^v-.+$/i; // Build a Tooltip config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n\nvar parseBindings = function parseBindings(bindings, vnode)\n/* istanbul ignore next: not easy to test */\n{\n  // We start out with a basic config\n  var NAME = 'BTooltip'; // Default config\n\n  var config = {\n    title: undefined,\n    trigger: '',\n    // Default set below if needed\n    placement: 'top',\n    fallbackPlacement: 'flip',\n    container: false,\n    // Default of body\n    animation: true,\n    offset: 0,\n    id: null,\n    html: false,\n    disabled: false,\n    delay: getComponentConfig(NAME, 'delay'),\n    boundary: String(getComponentConfig(NAME, 'boundary')),\n    boundaryPadding: parseInt(getComponentConfig(NAME, 'boundaryPadding'), 10) || 0,\n    variant: getComponentConfig(NAME, 'variant'),\n    customClass: getComponentConfig(NAME, 'customClass')\n  }; // Process `bindings.value`\n\n  if (isString(bindings.value) || isNumber(bindings.value)) {\n    // Value is tooltip content (HTML optionally supported)\n    config.title = bindings.value;\n  } else if (isFunction(bindings.value)) {\n    // Title generator function\n    config.title = bindings.value;\n  } else if (isPlainObject(bindings.value)) {\n    // Value is config object, so merge\n    config = _objectSpread({}, config, {}, bindings.value);\n  } // If title is not provided, try title attribute\n\n\n  if (isUndefined(config.title)) {\n    // Try attribute\n    var data = vnode.data || {};\n    config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined;\n  } // Normalize delay\n\n\n  if (!isPlainObject(config.delay)) {\n    config.delay = {\n      show: parseInt(config.delay, 10) || 0,\n      hide: parseInt(config.delay, 10) || 0\n    };\n  } // If argument, assume element ID of container element\n\n\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.container = \"#\".concat(bindings.arg);\n  } // Process modifiers\n\n\n  keys(bindings.modifiers).forEach(function (mod) {\n    if (htmlRE.test(mod)) {\n      // Title allows HTML\n      config.html = true;\n    } else if (noFadeRE.test(mod)) {\n      // No animation\n      config.animation = false;\n    } else if (placementRE.test(mod)) {\n      // Placement of tooltip\n      config.placement = mod;\n    } else if (boundaryRE.test(mod)) {\n      // Boundary of tooltip\n      mod = mod === 'scrollparent' ? 'scrollParent' : mod;\n      config.boundary = mod;\n    } else if (delayRE.test(mod)) {\n      // Delay value\n      var delay = parseInt(mod.slice(1), 10) || 0;\n      config.delay.show = delay;\n      config.delay.hide = delay;\n    } else if (delayShowRE.test(mod)) {\n      // Delay show value\n      config.delay.show = parseInt(mod.slice(2), 10) || 0;\n    } else if (delayHideRE.test(mod)) {\n      // Delay hide value\n      config.delay.hide = parseInt(mod.slice(2), 10) || 0;\n    } else if (offsetRE.test(mod)) {\n      // Offset value, negative allowed\n      config.offset = parseInt(mod.slice(1), 10) || 0;\n    } else if (variantRE.test(mod)) {\n      // Variant\n      config.variant = mod.slice(2) || null;\n    }\n  }); // Special handling of event trigger modifiers trigger is\n  // a space separated list\n\n  var selectedTriggers = {}; // Parse current config object trigger\n\n  concat(config.trigger || '').filter(Boolean).join(' ').trim().toLowerCase().split(/\\s+/).forEach(function (trigger) {\n    if (validTriggers[trigger]) {\n      selectedTriggers[trigger] = true;\n    }\n  }); // Parse modifiers for triggers\n\n  keys(bindings.modifiers).forEach(function (mod) {\n    mod = mod.toLowerCase();\n\n    if (validTriggers[mod]) {\n      // If modifier is a valid trigger\n      selectedTriggers[mod] = true;\n    }\n  }); // Sanitize triggers\n\n  config.trigger = keys(selectedTriggers).join(' ');\n\n  if (config.trigger === 'blur') {\n    // Blur by itself is useless, so convert it to 'focus'\n    config.trigger = 'focus';\n  }\n\n  if (!config.trigger) {\n    // Use default trigger\n    config.trigger = DefaultTrigger;\n  } // Return the config\n\n\n  return config;\n}; // Add/update Tooltip on our element\n\n\nvar applyTooltip = function applyTooltip(el, bindings, vnode) {\n  if (!isBrowser) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  var config = parseBindings(bindings, vnode);\n\n  if (!el[BV_TOOLTIP]) {\n    var $parent = vnode.context;\n    el[BV_TOOLTIP] = new BVTooltip({\n      parent: $parent,\n      // Add the parent's scoped style attribute data\n      _scopeId: getScopId($parent, undefined)\n    });\n    el[BV_TOOLTIP].__bv_prev_data__ = {};\n    el[BV_TOOLTIP].$on('show', function ()\n    /* istanbul ignore next: for now */\n    {\n      // Before showing the tooltip, we update the title if it is a function\n      if (isFunction(config.title)) {\n        el[BV_TOOLTIP].updateData({\n          title: config.title()\n        });\n      }\n    });\n  }\n\n  var data = {\n    title: config.title,\n    triggers: config.trigger,\n    placement: config.placement,\n    fallbackPlacement: config.fallbackPlacement,\n    variant: config.variant,\n    customClass: config.customClass,\n    container: config.container,\n    boundary: config.boundary,\n    delay: config.delay,\n    offset: config.offset,\n    noFade: !config.animation,\n    id: config.id,\n    disabled: config.disabled,\n    html: config.html\n  };\n  var oldData = el[BV_TOOLTIP].__bv_prev_data__;\n  el[BV_TOOLTIP].__bv_prev_data__ = data;\n\n  if (!looseEqual(data, oldData)) {\n    // We only update the instance if data has changed\n    var newData = {\n      target: el\n    };\n    keys(data).forEach(function (prop) {\n      // We only pass data properties that have changed\n      if (data[prop] !== oldData[prop]) {\n        // if title is a function, we execute it here\n        newData[prop] = prop === 'title' && isFunction(data[prop]) ? data[prop]() : data[prop];\n      }\n    });\n    el[BV_TOOLTIP].updateData(newData);\n  }\n}; // Remove Tooltip on our element\n\n\nvar removeTooltip = function removeTooltip(el) {\n  if (el[BV_TOOLTIP]) {\n    el[BV_TOOLTIP].$destroy();\n    el[BV_TOOLTIP] = null;\n  }\n\n  delete el[BV_TOOLTIP];\n}; // Export our directive\n\n\nexport var VBTooltip = {\n  bind: function bind(el, bindings, vnode) {\n    applyTooltip(el, bindings, vnode);\n  },\n  // We use `componentUpdated` here instead of `update`, as the former\n  // waits until the containing component and children have finished updating\n  componentUpdated: function componentUpdated(el, bindings, vnode) {\n    // Performed in a `$nextTick()` to prevent render update loops\n    vnode.context.$nextTick(function () {\n      applyTooltip(el, bindings, vnode);\n    });\n  },\n  unbind: function unbind(el) {\n    removeTooltip(el);\n  }\n};","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n * ScrollSpy class definition\n */\nimport observeDom from '../../utils/observe-dom';\nimport warn from '../../utils/warn';\nimport { isElement, isVisible, closest, matches, getBCR, offset, position, selectAll, select, hasClass, addClass, removeClass, getAttr, eventOn, eventOff } from '../../utils/dom';\nimport { isString, isUndefined } from '../../utils/inspect';\nimport { toString as objectToString } from '../../utils/object';\n/*\n * Constants / Defaults\n */\n\nvar NAME = 'v-b-scrollspy';\nvar ACTIVATE_EVENT = 'bv::scrollspy::activate';\nvar Default = {\n  element: 'body',\n  offset: 10,\n  method: 'auto',\n  throttle: 75\n};\nvar DefaultType = {\n  element: '(string|element|component)',\n  offset: 'number',\n  method: 'string',\n  throttle: 'number'\n};\nvar ClassName = {\n  DROPDOWN_ITEM: 'dropdown-item',\n  ACTIVE: 'active'\n};\nvar Selector = {\n  ACTIVE: '.active',\n  NAV_LIST_GROUP: '.nav, .list-group',\n  NAV_LINKS: '.nav-link',\n  NAV_ITEMS: '.nav-item',\n  LIST_ITEMS: '.list-group-item',\n  DROPDOWN: '.dropdown, .dropup',\n  DROPDOWN_ITEMS: '.dropdown-item',\n  DROPDOWN_TOGGLE: '.dropdown-toggle'\n};\nvar OffsetMethod = {\n  OFFSET: 'offset',\n  POSITION: 'position'\n}; // HREFs must end with a hash followed by at least one non-hash character.\n// HREFs in the links are assumed to point to non-external links.\n// Comparison to the current page base URL is not performed!\n\nvar HREF_REGEX = /^.*(#[^#]+)$/; // Transition Events\n\nvar TransitionEndEvents = ['webkitTransitionEnd', 'transitionend', 'otransitionend', 'oTransitionEnd']; // Options for events\n\nvar EventOptions = {\n  passive: true,\n  capture: false\n};\n/*\n * Utility Methods\n */\n// Better var type detection\n\nvar toType = function toType(obj)\n/* istanbul ignore next: not easy to test */\n{\n  return objectToString(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}; // Check config properties for expected types\n\n\nvar typeCheckConfig = function typeCheckConfig(componentName, config, configTypes)\n/* istanbul ignore next: not easy to test */\n{\n  for (var property in configTypes) {\n    if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n      var expectedTypes = configTypes[property];\n      var value = config[property];\n      var valueType = value && isElement(value) ? 'element' : toType(value); // handle Vue instances\n\n      valueType = value && value._isVue ? 'component' : valueType;\n\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        /* istanbul ignore next */\n        warn(\"\".concat(componentName, \": Option \\\"\").concat(property, \"\\\" provided type \\\"\").concat(valueType, \"\\\" but expected type \\\"\").concat(expectedTypes, \"\\\"\"));\n      }\n    }\n  }\n};\n/*\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\n/* istanbul ignore next: not easy to test */\n\n\nvar ScrollSpy\n/* istanbul ignore next: not easy to test */\n=\n/*#__PURE__*/\nfunction () {\n  function ScrollSpy(element, config, $root) {\n    _classCallCheck(this, ScrollSpy);\n\n    // The element we activate links in\n    this.$el = element;\n    this.$scroller = null;\n    this.$selector = [Selector.NAV_LINKS, Selector.LIST_ITEMS, Selector.DROPDOWN_ITEMS].join(',');\n    this.$offsets = [];\n    this.$targets = [];\n    this.$activeTarget = null;\n    this.$scrollHeight = 0;\n    this.$resizeTimeout = null;\n    this.$obs_scroller = null;\n    this.$obs_targets = null;\n    this.$root = $root || null;\n    this.$config = null;\n    this.updateConfig(config);\n  }\n\n  _createClass(ScrollSpy, [{\n    key: \"updateConfig\",\n    value: function updateConfig(config, $root) {\n      if (this.$scroller) {\n        // Just in case out scroll element has changed\n        this.unlisten();\n        this.$scroller = null;\n      }\n\n      var cfg = _objectSpread({}, this.constructor.Default, {}, config);\n\n      if ($root) {\n        this.$root = $root;\n      }\n\n      typeCheckConfig(this.constructor.Name, cfg, this.constructor.DefaultType);\n      this.$config = cfg;\n\n      if (this.$root) {\n        var self = this;\n        this.$root.$nextTick(function () {\n          self.listen();\n        });\n      } else {\n        this.listen();\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.unlisten();\n      clearTimeout(this.$resizeTimeout);\n      this.$resizeTimeout = null;\n      this.$el = null;\n      this.$config = null;\n      this.$scroller = null;\n      this.$selector = null;\n      this.$offsets = null;\n      this.$targets = null;\n      this.$activeTarget = null;\n      this.$scrollHeight = null;\n    }\n  }, {\n    key: \"listen\",\n    value: function listen() {\n      var _this = this;\n\n      var scroller = this.getScroller();\n\n      if (scroller && scroller.tagName !== 'BODY') {\n        eventOn(scroller, 'scroll', this, EventOptions);\n      }\n\n      eventOn(window, 'scroll', this, EventOptions);\n      eventOn(window, 'resize', this, EventOptions);\n      eventOn(window, 'orientationchange', this, EventOptions);\n      TransitionEndEvents.forEach(function (evtName) {\n        eventOn(window, evtName, _this, EventOptions);\n      });\n      this.setObservers(true); // Schedule a refresh\n\n      this.handleEvent('refresh');\n    }\n  }, {\n    key: \"unlisten\",\n    value: function unlisten() {\n      var _this2 = this;\n\n      var scroller = this.getScroller();\n      this.setObservers(false);\n\n      if (scroller && scroller.tagName !== 'BODY') {\n        eventOff(scroller, 'scroll', this, EventOptions);\n      }\n\n      eventOff(window, 'scroll', this, EventOptions);\n      eventOff(window, 'resize', this, EventOptions);\n      eventOff(window, 'orientationchange', this, EventOptions);\n      TransitionEndEvents.forEach(function (evtName) {\n        eventOff(window, evtName, _this2, EventOptions);\n      });\n    }\n  }, {\n    key: \"setObservers\",\n    value: function setObservers(on) {\n      var _this3 = this;\n\n      // We observe both the scroller for content changes, and the target links\n      if (this.$obs_scroller) {\n        this.$obs_scroller.disconnect();\n        this.$obs_scroller = null;\n      }\n\n      if (this.$obs_targets) {\n        this.$obs_targets.disconnect();\n        this.$obs_targets = null;\n      }\n\n      if (on) {\n        this.$obs_targets = observeDom(this.$el, function () {\n          _this3.handleEvent('mutation');\n        }, {\n          subtree: true,\n          childList: true,\n          attributes: true,\n          attributeFilter: ['href']\n        });\n        this.$obs_scroller = observeDom(this.getScroller(), function () {\n          _this3.handleEvent('mutation');\n        }, {\n          subtree: true,\n          childList: true,\n          characterData: true,\n          attributes: true,\n          attributeFilter: ['id', 'style', 'class']\n        });\n      }\n    } // General event handler\n\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(evt) {\n      var type = isString(evt) ? evt : evt.type;\n      var self = this;\n\n      var resizeThrottle = function resizeThrottle() {\n        if (!self.$resizeTimeout) {\n          self.$resizeTimeout = setTimeout(function () {\n            self.refresh();\n            self.process();\n            self.$resizeTimeout = null;\n          }, self.$config.throttle);\n        }\n      };\n\n      if (type === 'scroll') {\n        if (!this.$obs_scroller) {\n          // Just in case we are added to the DOM before the scroll target is\n          // We re-instantiate our listeners, just in case\n          this.listen();\n        }\n\n        this.process();\n      } else if (/(resize|orientationchange|mutation|refresh)/.test(type)) {\n        // Postpone these events by throttle time\n        resizeThrottle();\n      }\n    } // Refresh the list of target links on the element we are applied to\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this4 = this;\n\n      var scroller = this.getScroller();\n\n      if (!scroller) {\n        return;\n      }\n\n      var autoMethod = scroller !== scroller.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;\n      var method = this.$config.method === 'auto' ? autoMethod : this.$config.method;\n      var methodFn = method === OffsetMethod.POSITION ? position : offset;\n      var offsetBase = method === OffsetMethod.POSITION ? this.getScrollTop() : 0;\n      this.$offsets = [];\n      this.$targets = [];\n      this.$scrollHeight = this.getScrollHeight(); // Find all the unique link HREFs that we will control\n\n      selectAll(this.$selector, this.$el) // Get HREF value\n      .map(function (link) {\n        return getAttr(link, 'href');\n      }) // Filter out HREFs that do not match our RegExp\n      .filter(function (href) {\n        return href && HREF_REGEX.test(href || '');\n      }) // Find all elements with ID that match HREF hash\n      .map(function (href) {\n        // Convert HREF into an ID (including # at beginning)\n        var id = href.replace(HREF_REGEX, '$1').trim();\n\n        if (!id) {\n          return null;\n        } // Find the element with the ID specified by id\n\n\n        var el = select(id, scroller);\n\n        if (el && isVisible(el)) {\n          return {\n            offset: parseInt(methodFn(el).top, 10) + offsetBase,\n            target: id\n          };\n        }\n\n        return null;\n      }).filter(Boolean) // Sort them by their offsets (smallest first)\n      .sort(function (a, b) {\n        return a.offset - b.offset;\n      }) // record only unique targets/offsets\n      .reduce(function (memo, item) {\n        if (!memo[item.target]) {\n          _this4.$offsets.push(item.offset);\n\n          _this4.$targets.push(item.target);\n\n          memo[item.target] = true;\n        }\n\n        return memo;\n      }, {}); // Return this for easy chaining\n\n      return this;\n    } // Handle activating/clearing\n\n  }, {\n    key: \"process\",\n    value: function process() {\n      var scrollTop = this.getScrollTop() + this.$config.offset;\n      var scrollHeight = this.getScrollHeight();\n      var maxScroll = this.$config.offset + scrollHeight - this.getOffsetHeight();\n\n      if (this.$scrollHeight !== scrollHeight) {\n        this.refresh();\n      }\n\n      if (scrollTop >= maxScroll) {\n        var target = this.$targets[this.$targets.length - 1];\n\n        if (this.$activeTarget !== target) {\n          this.activate(target);\n        }\n\n        return;\n      }\n\n      if (this.$activeTarget && scrollTop < this.$offsets[0] && this.$offsets[0] > 0) {\n        this.$activeTarget = null;\n        this.clear();\n        return;\n      }\n\n      for (var i = this.$offsets.length; i--;) {\n        var isActiveTarget = this.$activeTarget !== this.$targets[i] && scrollTop >= this.$offsets[i] && (isUndefined(this.$offsets[i + 1]) || scrollTop < this.$offsets[i + 1]);\n\n        if (isActiveTarget) {\n          this.activate(this.$targets[i]);\n        }\n      }\n    }\n  }, {\n    key: \"getScroller\",\n    value: function getScroller() {\n      if (this.$scroller) {\n        return this.$scroller;\n      }\n\n      var scroller = this.$config.element;\n\n      if (!scroller) {\n        return null;\n      } else if (isElement(scroller.$el)) {\n        scroller = scroller.$el;\n      } else if (isString(scroller)) {\n        scroller = select(scroller);\n      }\n\n      if (!scroller) {\n        return null;\n      }\n\n      this.$scroller = scroller.tagName === 'BODY' ? window : scroller;\n      return this.$scroller;\n    }\n  }, {\n    key: \"getScrollTop\",\n    value: function getScrollTop() {\n      var scroller = this.getScroller();\n      return scroller === window ? scroller.pageYOffset : scroller.scrollTop;\n    }\n  }, {\n    key: \"getScrollHeight\",\n    value: function getScrollHeight() {\n      return this.getScroller().scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    }\n  }, {\n    key: \"getOffsetHeight\",\n    value: function getOffsetHeight() {\n      var scroller = this.getScroller();\n      return scroller === window ? window.innerHeight : getBCR(scroller).height;\n    }\n  }, {\n    key: \"activate\",\n    value: function activate(target) {\n      var _this5 = this;\n\n      this.$activeTarget = target;\n      this.clear(); // Grab the list of target links (<a href=\"{$target}\">)\n\n      var links = selectAll(this.$selector // Split out the base selectors\n      .split(',') // Map to a selector that matches links with HREF ending in the ID (including '#')\n      .map(function (selector) {\n        return \"\".concat(selector, \"[href$=\\\"\").concat(target, \"\\\"]\");\n      }) // Join back into a single selector string\n      .join(','), this.$el);\n      links.forEach(function (link) {\n        if (hasClass(link, ClassName.DROPDOWN_ITEM)) {\n          // This is a dropdown item, so find the .dropdown-toggle and set it's state\n          var dropdown = closest(Selector.DROPDOWN, link);\n\n          if (dropdown) {\n            _this5.setActiveState(select(Selector.DROPDOWN_TOGGLE, dropdown), true);\n          } // Also set this link's state\n\n\n          _this5.setActiveState(link, true);\n        } else {\n          // Set triggered link as active\n          _this5.setActiveState(link, true);\n\n          if (matches(link.parentElement, Selector.NAV_ITEMS)) {\n            // Handle nav-link inside nav-item, and set nav-item active\n            _this5.setActiveState(link.parentElement, true);\n          } // Set triggered links parents as active\n          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n\n\n          var el = link;\n\n          while (el) {\n            el = closest(Selector.NAV_LIST_GROUP, el);\n            var sibling = el ? el.previousElementSibling : null;\n\n            if (sibling && matches(sibling, \"\".concat(Selector.NAV_LINKS, \", \").concat(Selector.LIST_ITEMS))) {\n              _this5.setActiveState(sibling, true);\n            } // Handle special case where nav-link is inside a nav-item\n\n\n            if (sibling && matches(sibling, Selector.NAV_ITEMS)) {\n              _this5.setActiveState(select(Selector.NAV_LINKS, sibling), true); // Add active state to nav-item as well\n\n\n              _this5.setActiveState(sibling, true);\n            }\n          }\n        }\n      }); // Signal event to via $root, passing ID of activated target and reference to array of links\n\n      if (links && links.length > 0 && this.$root) {\n        this.$root.$emit(ACTIVATE_EVENT, target, links);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this6 = this;\n\n      selectAll(\"\".concat(this.$selector, \", \").concat(Selector.NAV_ITEMS), this.$el).filter(function (el) {\n        return hasClass(el, ClassName.ACTIVE);\n      }).forEach(function (el) {\n        return _this6.setActiveState(el, false);\n      });\n    }\n  }, {\n    key: \"setActiveState\",\n    value: function setActiveState(el, active) {\n      if (!el) {\n        return;\n      }\n\n      if (active) {\n        addClass(el, ClassName.ACTIVE);\n      } else {\n        removeClass(el, ClassName.ACTIVE);\n      }\n    }\n  }], [{\n    key: \"Name\",\n    get: function get() {\n      return NAME;\n    }\n  }, {\n    key: \"Default\",\n    get: function get() {\n      return Default;\n    }\n  }, {\n    key: \"DefaultType\",\n    get: function get() {\n      return DefaultType;\n    }\n  }]);\n\n  return ScrollSpy;\n}();\n\nexport default ScrollSpy;","import ScrollSpy from './scrollspy.class';\nimport { isBrowser } from '../../utils/env';\nimport { keys } from '../../utils/object';\nimport { isNumber, isObject, isString } from '../../utils/inspect'; // Key we use to store our instance\n\nvar BV_SCROLLSPY = '__BV_ScrollSpy__'; // Build a ScrollSpy config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n\n/* istanbul ignore next: not easy to test */\n\nvar parseBindings = function parseBindings(bindings)\n/* istanbul ignore next: not easy to test */\n{\n  var config = {}; // If argument, assume element ID\n\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.element = \"#\".concat(bindings.arg);\n  } // Process modifiers\n\n\n  keys(bindings.modifiers).forEach(function (mod) {\n    if (/^\\d+$/.test(mod)) {\n      // Offset value\n      config.offset = parseInt(mod, 10);\n    } else if (/^(auto|position|offset)$/.test(mod)) {\n      // Offset method\n      config.method = mod;\n    }\n  }); // Process value\n\n  if (isString(bindings.value)) {\n    // Value is a CSS ID or selector\n    config.element = bindings.value;\n  } else if (isNumber(bindings.value)) {\n    // Value is offset\n    config.offset = Math.round(bindings.value);\n  } else if (isObject(bindings.value)) {\n    // Value is config object\n    // Filter the object based on our supported config options\n    keys(bindings.value).filter(function (k) {\n      return Boolean(ScrollSpy.DefaultType[k]);\n    }).forEach(function (k) {\n      config[k] = bindings.value[k];\n    });\n  }\n\n  return config;\n}; // Add or update ScrollSpy on our element\n\n\nvar applyScrollspy = function applyScrollspy(el, bindings, vnode)\n/* istanbul ignore next: not easy to test */\n{\n  if (!isBrowser) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  var config = parseBindings(bindings);\n\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].updateConfig(config, vnode.context.$root);\n  } else {\n    el[BV_SCROLLSPY] = new ScrollSpy(el, config, vnode.context.$root);\n  }\n}; // Remove ScrollSpy on our element\n\n/* istanbul ignore next: not easy to test */\n\n\nvar removeScrollspy = function removeScrollspy(el)\n/* istanbul ignore next: not easy to test */\n{\n  if (el[BV_SCROLLSPY]) {\n    el[BV_SCROLLSPY].dispose();\n    el[BV_SCROLLSPY] = null;\n    delete el[BV_SCROLLSPY];\n  }\n};\n/*\n * Export our directive\n */\n\n\nexport var VBScrollspy = {\n  bind: function bind(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    applyScrollspy(el, bindings, vnode);\n  },\n  inserted: function inserted(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    applyScrollspy(el, bindings, vnode);\n  },\n  update: function update(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n  componentUpdated: function componentUpdated(el, bindings, vnode)\n  /* istanbul ignore next: not easy to test */\n  {\n    if (bindings.value !== bindings.oldValue) {\n      applyScrollspy(el, bindings, vnode);\n    }\n  },\n  unbind: function unbind(el)\n  /* istanbul ignore next: not easy to test */\n  {\n    removeScrollspy(el);\n  }\n};","import { VBPopover } from './popover';\nimport { pluginFactory } from '../../utils/plugins';\nvar VBPopoverPlugin =\n/*#__PURE__*/\npluginFactory({\n  directives: {\n    VBPopover: VBPopover\n  }\n});\nexport { VBPopoverPlugin, VBPopover };","import looseEqual from '../../utils/loose-equal';\nimport { addClass, hasAttr, removeAttr, removeClass, setAttr } from '../../utils/dom';\nimport { isBrowser } from '../../utils/env';\nimport { bindTargets, getTargets, unbindTargets } from '../../utils/target'; // Target listen types\n\nvar listenTypes = {\n  click: true\n}; // Property key for handler storage\n\nvar BV_TOGGLE = '__BV_toggle__';\nvar BV_TOGGLE_STATE = '__BV_toggle_STATE__';\nvar BV_TOGGLE_CONTROLS = '__BV_toggle_CONTROLS__';\nvar BV_TOGGLE_TARGETS = '__BV_toggle_TARGETS__'; // Emitted control event for collapse (emitted to collapse)\n\nvar EVENT_TOGGLE = 'bv::toggle::collapse'; // Listen to event for toggle state update (emitted by collapse)\n\nvar EVENT_STATE = 'bv::collapse::state'; // Private event emitted on $root to ensure the toggle state is always synced.\n// Gets emitted even if the state of b-collapse has not changed.\n// This event is NOT to be documented as people should not be using it.\n\nvar EVENT_STATE_SYNC = 'bv::collapse::sync::state'; // Private event we send to collapse to request state update sync event\n\nvar EVENT_STATE_REQUEST = 'bv::request::collapse::state'; // Reset and remove a property from the provided element\n\nvar resetProp = function resetProp(el, prop) {\n  el[prop] = null;\n  delete el[prop];\n}; // Handle targets update\n\n\nvar handleTargets = function handleTargets(_ref) {\n  var targets = _ref.targets,\n      vnode = _ref.vnode;\n  targets.forEach(function (target) {\n    vnode.context.$root.$emit(EVENT_TOGGLE, target);\n  });\n}; // Handle directive updates\n\n/* istanbul ignore next: not easy to test */\n\n\nvar handleUpdate = function handleUpdate(el, binding, vnode) {\n  if (!isBrowser) {\n    return;\n  }\n\n  if (!looseEqual(getTargets(binding), el[BV_TOGGLE_TARGETS])) {\n    // Targets have changed, so update accordingly\n    unbindTargets(vnode, binding, listenTypes);\n    var targets = bindTargets(vnode, binding, listenTypes, handleTargets); // Update targets array to element\n\n    el[BV_TOGGLE_TARGETS] = targets; // Add aria attributes to element\n\n    el[BV_TOGGLE_CONTROLS] = targets.join(' '); // ensure aria-controls is up to date\n\n    setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]); // Request a state update from targets so that we can ensure\n    // expanded state is correct\n\n    targets.forEach(function (target) {\n      vnode.context.$root.$emit(EVENT_STATE_REQUEST, target);\n    });\n  } // Ensure the collapse class and aria-* attributes persist\n  // after element is updated (either by parent re-rendering\n  // or changes to this element or it's contents\n\n\n  if (el[BV_TOGGLE_STATE] === true) {\n    addClass(el, 'collapsed');\n    setAttr(el, 'aria-expanded', 'true');\n  } else if (el[BV_TOGGLE_STATE] === false) {\n    removeClass(el, 'collapsed');\n    setAttr(el, 'aria-expanded', 'false');\n  }\n\n  setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]);\n};\n/*\n * Export our directive\n */\n\n\nexport var VBToggle = {\n  bind: function bind(el, binding, vnode) {\n    var targets = bindTargets(vnode, binding, listenTypes, handleTargets);\n\n    if (isBrowser && vnode.context && targets.length > 0) {\n      // Add targets array to element\n      el[BV_TOGGLE_TARGETS] = targets; // Add aria attributes to element\n\n      el[BV_TOGGLE_CONTROLS] = targets.join(' '); // State is initially collapsed until we receive a state event\n\n      el[BV_TOGGLE_STATE] = false;\n      setAttr(el, 'aria-controls', el[BV_TOGGLE_CONTROLS]);\n      setAttr(el, 'aria-expanded', 'false'); // If element is not a button, we add `role=\"button\"` for accessibility\n\n      if (el.tagName !== 'BUTTON' && !hasAttr(el, 'role')) {\n        setAttr(el, 'role', 'button');\n      } // Toggle state handler\n\n\n      var toggleDirectiveHandler = function toggleDirectiveHandler(id, state) {\n        var targets = el[BV_TOGGLE_TARGETS] || [];\n\n        if (targets.indexOf(id) !== -1) {\n          // Set aria-expanded state\n          setAttr(el, 'aria-expanded', state ? 'true' : 'false'); // Set/Clear 'collapsed' class state\n\n          el[BV_TOGGLE_STATE] = state;\n\n          if (state) {\n            removeClass(el, 'collapsed');\n          } else {\n            addClass(el, 'collapsed');\n          }\n        }\n      }; // Store the toggle handler on the element\n\n\n      el[BV_TOGGLE] = toggleDirectiveHandler; // Listen for toggle state changes (public)\n\n      vnode.context.$root.$on(EVENT_STATE, el[BV_TOGGLE]); // Listen for toggle state sync (private)\n\n      vnode.context.$root.$on(EVENT_STATE_SYNC, el[BV_TOGGLE]);\n    }\n  },\n  componentUpdated: handleUpdate,\n  updated: handleUpdate,\n  unbind: function unbind(el, binding, vnode)\n  /* istanbul ignore next */\n  {\n    unbindTargets(vnode, binding, listenTypes); // Remove our $root listener\n\n    if (el[BV_TOGGLE]) {\n      vnode.context.$root.$off(EVENT_STATE, el[BV_TOGGLE]);\n      vnode.context.$root.$off(EVENT_STATE_SYNC, el[BV_TOGGLE]);\n    } // Reset custom  props\n\n\n    resetProp(el, BV_TOGGLE);\n    resetProp(el, BV_TOGGLE_STATE);\n    resetProp(el, BV_TOGGLE_CONTROLS);\n    resetProp(el, BV_TOGGLE_TARGETS); // Reset classes/attrs\n\n    removeClass(el, 'collapsed');\n    removeAttr(el, 'aria-expanded');\n    removeAttr(el, 'aria-controls');\n    removeAttr(el, 'role');\n  }\n};","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// v-b-visible\n// Private visibility check directive\n// Based on IntersectionObserver\n//\n// Usage:\n//  v-b-visibility.<margin>.<once>=\"<callback>\"\n//\n//  Value:\n//  <callback>: method to be called when visibility state changes, receives one arg:\n//     true:  element is visible\n//     false: element is not visible\n//     null:  IntersectionObserver not supported\n//\n//  Modifiers:\n//    <margin>: a positive decimal value of pixels away from viewport edge\n//              before being considered \"visible\". default is 0\n//    <once>:   keyword 'once', meaning when the element becomes visible and\n//              callback is called observation/notification will stop.\n//\n// When used in a render function:\n// export default {\n//   directives: { 'b-visible': VBVisible },\n//   render(h) {\n//     h(\n//       'div',\n//       {\n//         directives: [\n//           { name: 'b-visible', value=this.callback, modifiers: { '123':true, 'once':true } }\n//         ]\n//       }\n//     )\n//   }\nimport looseEqual from '../utils/loose-equal';\nimport { requestAF } from '../utils/dom';\nimport { isFunction } from '../utils/inspect';\nimport { keys } from '../utils/object';\nvar OBSERVER_PROP_NAME = '__bv__visibility_observer';\n\nvar VisibilityObserver =\n/*#__PURE__*/\nfunction () {\n  function VisibilityObserver(el, options, vnode) {\n    _classCallCheck(this, VisibilityObserver);\n\n    this.el = el;\n    this.callback = options.callback;\n    this.margin = options.margin || 0;\n    this.once = options.once || false;\n    this.observer = null;\n    this.visible = undefined;\n    this.doneOnce = false; // Create the observer instance (if possible)\n\n    this.createObserver(vnode);\n  }\n\n  _createClass(VisibilityObserver, [{\n    key: \"createObserver\",\n    value: function createObserver(vnode) {\n      var _this = this;\n\n      // Remove any previous observer\n      if (this.observer) {\n        /* istanbul ignore next */\n        this.stop();\n      } // Should only be called once and `callback` prop should be a function\n\n\n      if (this.doneOnce || !isFunction(this.callback)) {\n        /* istanbul ignore next */\n        return;\n      } // Create the observer instance\n\n\n      try {\n        // Future: Possibly add in other modifiers for left/right/top/bottom\n        // offsets, root element reference, and thresholds\n        this.observer = new IntersectionObserver(this.handler.bind(this), {\n          // `null` = 'viewport'\n          root: null,\n          // Pixels away from view port to consider \"visible\"\n          rootMargin: this.margin,\n          // Intersection ratio of el and root (as a value from 0 to 1)\n          threshold: 0\n        });\n      } catch (_unused) {\n        // No IntersectionObserver support, so just stop trying to observe\n        this.doneOnce = true;\n        this.observer = undefined;\n        this.callback(null);\n        return;\n      } // Start observing in a `$nextTick()` (to allow DOM to complete rendering)\n\n      /* istanbul ignore next: IntersectionObserver not supported in JSDOM */\n\n\n      vnode.context.$nextTick(function () {\n        requestAF(function () {\n          // Placed in an `if` just in case we were destroyed before\n          // this `requestAnimationFrame` runs\n          if (_this.observer) {\n            _this.observer.observe(_this.el);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"handler\",\n    value: function handler(entries)\n    /* istanbul ignore next: IntersectionObserver not supported in JSDOM */\n    {\n      var entry = entries ? entries[0] : {};\n      var isIntersecting = Boolean(entry.isIntersecting || entry.intersectionRatio > 0.0);\n\n      if (isIntersecting !== this.visible) {\n        this.visible = isIntersecting;\n        this.callback(isIntersecting);\n\n        if (this.once && this.visible) {\n          this.doneOnce = true;\n          this.stop();\n        }\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var observer = this.observer;\n      /* istanbul ignore next */\n\n      if (observer && observer.disconnect) {\n        observer.disconnect();\n      }\n\n      this.observer = null;\n    }\n  }]);\n\n  return VisibilityObserver;\n}();\n\nvar destroy = function destroy(el) {\n  var observer = el[OBSERVER_PROP_NAME];\n\n  if (observer && observer.stop) {\n    observer.stop();\n  }\n\n  delete el[OBSERVER_PROP_NAME];\n};\n\nvar bind = function bind(el, _ref, vnode) {\n  var value = _ref.value,\n      modifiers = _ref.modifiers;\n  // `value` is the callback function\n  var options = {\n    margin: '0px',\n    once: false,\n    callback: value\n  }; // Parse modifiers\n\n  keys(modifiers).forEach(function (mod) {\n    /* istanbul ignore else: Until <b-img-lazy> is switched to use this directive */\n    if (/^\\d+$/.test(mod)) {\n      options.margin = \"\".concat(mod, \"px\");\n    } else if (mod.toLowerCase() === 'once') {\n      options.once = true;\n    }\n  }); // Destroy any previous observer\n\n  destroy(el); // Create new observer\n\n  el[OBSERVER_PROP_NAME] = new VisibilityObserver(el, options, vnode); // Store the current modifiers on the object (cloned)\n\n  el[OBSERVER_PROP_NAME]._prevModifiers = _objectSpread({}, modifiers);\n}; // When the directive options may have been updated (or element)\n\n\nvar componentUpdated = function componentUpdated(el, _ref2, vnode) {\n  var value = _ref2.value,\n      oldValue = _ref2.oldValue,\n      modifiers = _ref2.modifiers;\n\n  // Compare value/oldValue and modifiers to see if anything has changed\n  // and if so, destroy old observer and create new observer\n\n  /* istanbul ignore next */\n  if (value !== oldValue || !el[OBSERVER_PROP_NAME] || !looseEqual(modifiers, el[OBSERVER_PROP_NAME]._prevModifiers)) {\n    // Re-bind on element\n    bind(el, {\n      value: value,\n      modifiers: modifiers\n    }, vnode);\n  }\n}; // When directive un-binds from element\n\n\nvar unbind = function unbind(el) {\n  // Remove the observer\n  destroy(el);\n}; // Export the directive\n\n\nexport var VBVisible = {\n  bind: bind,\n  componentUpdated: componentUpdated,\n  unbind: unbind\n};","import { VBTooltip } from './tooltip';\nimport { pluginFactory } from '../../utils/plugins';\nvar VBTooltipPlugin =\n/*#__PURE__*/\npluginFactory({\n  directives: {\n    VBTooltip: VBTooltip\n  }\n});\nexport { VBTooltipPlugin, VBTooltip };","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport getScopId from '../../utils/get-scope-id';\nimport looseEqual from '../../utils/loose-equal';\nimport { concat } from '../../utils/array';\nimport { getComponentConfig } from '../../utils/config';\nimport { isBrowser } from '../../utils/env';\nimport { isFunction, isNumber, isPlainObject, isString, isUndefined, isUndefinedOrNull } from '../../utils/inspect';\nimport { keys } from '../../utils/object';\nimport { BVPopover } from '../../components/popover/helpers/bv-popover'; // Key which we use to store tooltip object on element\n\nvar BV_POPOVER = '__BV_Popover__'; // Default trigger\n\nvar DefaultTrigger = 'click'; // Valid event triggers\n\nvar validTriggers = {\n  focus: true,\n  hover: true,\n  click: true,\n  blur: true,\n  manual: true\n}; // Directive modifier test regular expressions. Pre-compile for performance\n\nvar htmlRE = /^html$/i;\nvar noFadeRE = /^nofade$/i;\nvar placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;\nvar boundaryRE = /^(window|viewport|scrollParent)$/i;\nvar delayRE = /^d\\d+$/i;\nvar delayShowRE = /^ds\\d+$/i;\nvar delayHideRE = /^dh\\d+$/i;\nvar offsetRE = /^o-?\\d+$/i;\nvar variantRE = /^v-.+$/i; // Build a Popover config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n\nvar parseBindings = function parseBindings(bindings, vnode)\n/* istanbul ignore next: not easy to test */\n{\n  // We start out with a basic config\n  var NAME = 'BPopover';\n  var config = {\n    title: undefined,\n    content: undefined,\n    trigger: '',\n    // Default set below if needed\n    placement: 'right',\n    fallbackPlacement: 'flip',\n    container: false,\n    // Default of body\n    animation: true,\n    offset: 0,\n    disabled: false,\n    id: null,\n    html: false,\n    delay: getComponentConfig(NAME, 'delay'),\n    boundary: String(getComponentConfig(NAME, 'boundary')),\n    boundaryPadding: parseInt(getComponentConfig(NAME, 'boundaryPadding'), 10) || 0,\n    variant: getComponentConfig(NAME, 'variant'),\n    customClass: getComponentConfig(NAME, 'customClass')\n  }; // Process `bindings.value`\n\n  if (isString(bindings.value) || isNumber(bindings.value)) {\n    // Value is popover content (html optionally supported)\n    config.content = bindings.value;\n  } else if (isFunction(bindings.value)) {\n    // Content generator function\n    config.content = bindings.value;\n  } else if (isPlainObject(bindings.value)) {\n    // Value is config object, so merge\n    config = _objectSpread({}, config, {}, bindings.value);\n  } // If argument, assume element ID of container element\n\n\n  if (bindings.arg) {\n    // Element ID specified as arg\n    // We must prepend '#' to become a CSS selector\n    config.container = \"#\".concat(bindings.arg);\n  } // If title is not provided, try title attribute\n\n\n  if (isUndefined(config.title)) {\n    // Try attribute\n    var data = vnode.data || {};\n    config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : undefined;\n  } // Normalize delay\n\n\n  if (!isPlainObject(config.delay)) {\n    config.delay = {\n      show: parseInt(config.delay, 10) || 0,\n      hide: parseInt(config.delay, 10) || 0\n    };\n  } // Process modifiers\n\n\n  keys(bindings.modifiers).forEach(function (mod) {\n    if (htmlRE.test(mod)) {\n      // Title/content allows HTML\n      config.html = true;\n    } else if (noFadeRE.test(mod)) {\n      // No animation\n      config.animation = false;\n    } else if (placementRE.test(mod)) {\n      // Placement of popover\n      config.placement = mod;\n    } else if (boundaryRE.test(mod)) {\n      // Boundary of popover\n      mod = mod === 'scrollparent' ? 'scrollParent' : mod;\n      config.boundary = mod;\n    } else if (delayRE.test(mod)) {\n      // Delay value\n      var delay = parseInt(mod.slice(1), 10) || 0;\n      config.delay.show = delay;\n      config.delay.hide = delay;\n    } else if (delayShowRE.test(mod)) {\n      // Delay show value\n      config.delay.show = parseInt(mod.slice(2), 10) || 0;\n    } else if (delayHideRE.test(mod)) {\n      // Delay hide value\n      config.delay.hide = parseInt(mod.slice(2), 10) || 0;\n    } else if (offsetRE.test(mod)) {\n      // Offset value, negative allowed\n      config.offset = parseInt(mod.slice(1), 10) || 0;\n    } else if (variantRE.test(mod)) {\n      // Variant\n      config.variant = mod.slice(2) || null;\n    }\n  }); // Special handling of event trigger modifiers trigger is\n  // a space separated list\n\n  var selectedTriggers = {}; // Parse current config object trigger\n\n  concat(config.trigger || '').filter(Boolean).join(' ').trim().toLowerCase().split(/\\s+/).forEach(function (trigger) {\n    if (validTriggers[trigger]) {\n      selectedTriggers[trigger] = true;\n    }\n  }); // Parse modifiers for triggers\n\n  keys(bindings.modifiers).forEach(function (mod) {\n    mod = mod.toLowerCase();\n\n    if (validTriggers[mod]) {\n      // If modifier is a valid trigger\n      selectedTriggers[mod] = true;\n    }\n  }); // Sanitize triggers\n\n  config.trigger = keys(selectedTriggers).join(' ');\n\n  if (config.trigger === 'blur') {\n    // Blur by itself is useless, so convert it to 'focus'\n    config.trigger = 'focus';\n  }\n\n  if (!config.trigger) {\n    // Use default trigger\n    config.trigger = DefaultTrigger;\n  }\n\n  return config;\n}; // Add or update Popover on our element\n\n\nvar applyPopover = function applyPopover(el, bindings, vnode) {\n  if (!isBrowser) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  var config = parseBindings(bindings, vnode);\n\n  if (!el[BV_POPOVER]) {\n    var $parent = vnode.context;\n    el[BV_POPOVER] = new BVPopover({\n      parent: $parent,\n      // Add the parent's scoped style attribute data\n      _scopeId: getScopId($parent, undefined)\n    });\n    el[BV_POPOVER].__bv_prev_data__ = {};\n    el[BV_POPOVER].$on('show', function ()\n    /* istanbul ignore next: for now */\n    {\n      // Before showing the popover, we update the title\n      // and content if they are functions\n      var data = {};\n\n      if (isFunction(config.title)) {\n        data.title = config.title();\n      }\n\n      if (isFunction(config.content)) {\n        data.content = config.content();\n      }\n\n      if (keys(data).length > 0) {\n        el[BV_POPOVER].updateData(data);\n      }\n    });\n  }\n\n  var data = {\n    title: config.title,\n    content: config.content,\n    triggers: config.trigger,\n    placement: config.placement,\n    fallbackPlacement: config.fallbackPlacement,\n    variant: config.variant,\n    customClass: config.customClass,\n    container: config.container,\n    boundary: config.boundary,\n    delay: config.delay,\n    offset: config.offset,\n    noFade: !config.animation,\n    id: config.id,\n    disabled: config.disabled,\n    html: config.html\n  };\n  var oldData = el[BV_POPOVER].__bv_prev_data__;\n  el[BV_POPOVER].__bv_prev_data__ = data;\n\n  if (!looseEqual(data, oldData)) {\n    // We only update the instance if data has changed\n    var newData = {\n      target: el\n    };\n    keys(data).forEach(function (prop) {\n      // We only pass data properties that have changed\n      if (data[prop] !== oldData[prop]) {\n        // If title/content is a function, we execute it here\n        newData[prop] = (prop === 'title' || prop === 'content') && isFunction(data[prop]) ? data[prop]() : data[prop];\n      }\n    });\n    el[BV_POPOVER].updateData(newData);\n  }\n}; // Remove Popover from our element\n\n\nvar removePopover = function removePopover(el) {\n  if (el[BV_POPOVER]) {\n    el[BV_POPOVER].$destroy();\n    el[BV_POPOVER] = null;\n  }\n\n  delete el[BV_POPOVER];\n}; // Export our directive\n\n\nexport var VBPopover = {\n  bind: function bind(el, bindings, vnode) {\n    applyPopover(el, bindings, vnode);\n  },\n  // We use `componentUpdated` here instead of `update`, as the former\n  // waits until the containing component and children have finished updating\n  componentUpdated: function componentUpdated(el, bindings, vnode) {\n    // Performed in a `$nextTick()` to prevent endless render/update loops\n    vnode.context.$nextTick(function () {\n      applyPopover(el, bindings, vnode);\n    });\n  },\n  unbind: function unbind(el) {\n    removePopover(el);\n  }\n};","import { VBModal } from './modal';\nimport { pluginFactory } from '../../utils/plugins';\nvar VBModalPlugin =\n/*#__PURE__*/\npluginFactory({\n  directives: {\n    VBModal: VBModal\n  }\n});\nexport { VBModalPlugin, VBModal };","import { eventOn, eventOff, getAttr, hasAttr, isDisabled, matches, select, setAttr } from '../../utils/dom';\nimport { isString } from '../../utils/inspect';\nimport { keys } from '../../utils/object'; // Emitted show event for modal\n\nvar EVENT_SHOW = 'bv::show::modal'; // Prop name we use to store info on root element\n\nvar HANDLER = '__bv_modal_directive__';\nvar EVENT_OPTS = {\n  passive: true\n};\n\nvar getTarget = function getTarget(_ref) {\n  var _ref$modifiers = _ref.modifiers,\n      modifiers = _ref$modifiers === void 0 ? {} : _ref$modifiers,\n      arg = _ref.arg,\n      value = _ref.value;\n  // Try value, then arg, otherwise pick last modifier\n  return isString(value) ? value : isString(arg) ? arg : keys(modifiers).reverse()[0];\n};\n\nvar getTriggerElement = function getTriggerElement(el) {\n  // If root element is a dropdown item or nav item, we\n  // need to target the inner link or button instead\n  return el && matches(el, '.dropdown-menu > li, li.nav-item') ? select('a, button', el) || el : el;\n};\n\nvar setRole = function setRole(trigger) {\n  // Only set a role if the trigger element doesn't have one\n  if (trigger && trigger.tagName !== 'BUTTON' && !hasAttr(trigger, 'role')) {\n    setAttr(trigger, 'role', 'button');\n  }\n};\n\nvar bind = function bind(el, binding, vnode) {\n  var target = getTarget(binding);\n  var trigger = getTriggerElement(el);\n\n  if (target && trigger) {\n    var handler = function handler(evt) {\n      // `currentTarget` is the element with the listener on it\n      var currentTarget = evt.currentTarget;\n\n      if (!isDisabled(currentTarget)) {\n        var type = evt.type; // Open modal only if trigger is not disabled\n\n        if (type === 'click' || type === 'keydown' && evt.keyCode === 32) {\n          vnode.context.$root.$emit(EVENT_SHOW, target, currentTarget);\n        }\n      }\n    };\n\n    el[HANDLER] = handler; // If element is not a button, we add `role=\"button\"` for accessibility\n\n    setRole(trigger); // Listen for click events\n\n    eventOn(trigger, 'click', handler, EVENT_OPTS);\n\n    if (trigger.tagName !== 'BUTTON' && getAttr(trigger, 'role') === 'button') {\n      // If trigger isn't a button but has role button,\n      // we also listen for `keydown.space`\n      eventOn(trigger, 'keydown', handler, EVENT_OPTS);\n    }\n  }\n};\n\nvar unbind = function unbind(el) {\n  var trigger = getTriggerElement(el);\n  var handler = el ? el[HANDLER] : null;\n\n  if (trigger && handler) {\n    eventOff(trigger, 'click', handler, EVENT_OPTS);\n    eventOff(trigger, 'keydown', handler, EVENT_OPTS);\n  }\n\n  delete el[HANDLER];\n};\n\nvar componentUpdated = function componentUpdated(el, binding, vnode) {\n  // We bind and rebind just in case target changes\n  unbind(el, binding, vnode);\n  bind(el, binding, vnode);\n};\n\nvar updated = function updated() {};\n/*\n * Export our directive\n */\n\n\nexport var VBModal = {\n  inserted: componentUpdated,\n  updated: updated,\n  componentUpdated: componentUpdated,\n  unbind: unbind\n};","import { VBToggle } from './toggle';\nimport { pluginFactory } from '../../utils/plugins';\nvar VBTogglePlugin =\n/*#__PURE__*/\npluginFactory({\n  directives: {\n    VBToggle: VBToggle\n  }\n});\nexport { VBTogglePlugin, VBToggle };","import { pluginFactory } from '../utils/plugins';\nimport { VBModalPlugin } from './modal';\nimport { VBPopoverPlugin } from './popover';\nimport { VBScrollspyPlugin } from './scrollspy';\nimport { VBTogglePlugin } from './toggle';\nimport { VBTooltipPlugin } from './tooltip'; // Main plugin for installing all directive plugins\n\nexport var directivesPlugin =\n/*#__PURE__*/\npluginFactory({\n  plugins: {\n    VBModalPlugin: VBModalPlugin,\n    VBPopoverPlugin: VBPopoverPlugin,\n    VBScrollspyPlugin: VBScrollspyPlugin,\n    VBTogglePlugin: VBTogglePlugin,\n    VBTooltipPlugin: VBTooltipPlugin\n  }\n});"],"sourceRoot":""}